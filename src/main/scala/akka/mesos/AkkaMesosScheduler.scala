package akka.mesos

import akka.actor.Actor
import akka.event.Logging

import org.apache.mesos.Protos._
import org.apache.mesos.{ Scheduler, SchedulerDriver, MesosSchedulerDriver }

import scala.concurrent.Future

import java.util.{ List => JList }

trait AkkaMesosScheduler { _: Actor =>

  import AkkaMesosScheduler._ // for event messages

  // Access to global Mesos configuration values
  private[this] val mesos: MesosImpl = Mesos(context.system)

  val log = Logging(context.system, this)

  /**
    * The name of this Mesos scheduler, used when registering with the
    * Mesos master.
    */
  val name: String = getClass.getSimpleName

  /**
    * The unique ID of this Mesos framework, used when registering
    * with the Mesos master.  If this is `None` (default) then the
    * master will create one on the framework's behalf at
    * registration time.
    */
  val frameworkId: Option[String] = Option(name)

  /**
    * The name of the user under which to run this framework, used
    * when registering with the Mesos master.  If this is `None`
    * (default) then the master will assign the user on the framework's
    * behalf.
    */
  val user: Option[String] = None

  // Framework metadata for registration with Mesos
  private[this] lazy val frameworkInfo: FrameworkInfo = {
    val builder = FrameworkInfo.newBuilder()
      .setName(this.name)
      .setFailoverTimeout(mesos.schedulerFailoverTimeout.toMillis)
      .setCheckpoint(true)

    builder.setUser(user.getOrElse(""))

    frameworkId.foreach { id =>
      builder.setId(FrameworkID.newBuilder.setValue(id))
    }

    builder.build
  }

  /**
    * This scheduler's associated driver.
    */
  protected[this] lazy val driver: SchedulerDriver =
    new MesosSchedulerDriver(proxy, frameworkInfo, mesos.master)

  /**
    * Returns the eventual exit status of the scheduler driver.
    */
  def register(): Future[Status] = {
    import context.dispatcher

    val exitStatus: Future[Status] = Future { driver.run }

    exitStatus.onFailure {
      case t: Throwable => log.error(
        "Driver threw an exception: [%s]\n%s".format(
          t.getClass.getName,
          t.getStackTrace.mkString("\n")
        )
      )
    }

    exitStatus.onSuccess {
      case status =>
        log.info("Driver exited with status [%s]" format status)
    }

    exitStatus
  }

  /**
    * Concrete implementations should handle subclasses of [SchedulerMessage].
    */
  def receive: PartialFunction[Any, Unit]

  private[this] lazy val proxy: Scheduler = new SchedulerProxy

  /**
    * This concrete scheduler proxies Mesos callbacks to the enclosing Actor.
    */
  protected class SchedulerProxy extends Scheduler {

    import scala.collection.JavaConverters._

    def registered(
      driver: SchedulerDriver,
      frameworkId: FrameworkID,
      masterInfo: MasterInfo): Unit =
      self ! Registered(frameworkId, masterInfo)

    def reregistered(
      driver: SchedulerDriver,
      masterInfo: MasterInfo): Unit =
      self ! Reregistered(masterInfo)

    def resourceOffers(
      driver: SchedulerDriver,
      offers: JList[Offer]): Unit =
      self ! ResourceOffers(offers.asScala)

    def offerRescinded(
      driver: SchedulerDriver,
      offerId: OfferID): Unit =
      self ! OfferRescinded(offerId)

    def statusUpdate(
      driver: SchedulerDriver,
      status: TaskStatus): Unit =
      self ! StatusUpdate(status)

    def frameworkMessage(
      driver: SchedulerDriver,
      executorId: ExecutorID,
      slaveId: SlaveID,
      data: Array[Byte]): Unit =
      self ! FrameworkMessage(executorId, slaveId, data.toSeq)

    def disconnected(driver: SchedulerDriver): Unit =
      self ! Disconnected()

    def slaveLost(
      driver: SchedulerDriver,
      slaveId: SlaveID): Unit =
      self ! SlaveLost(slaveId)

    def executorLost(
      driver: SchedulerDriver,
      executorId: ExecutorID,
      slaveId: SlaveID,
      status: Int): Unit =
      self ! ExecutorLost(executorId, slaveId, status)

    def error(driver: SchedulerDriver, message: String): Unit =
      self ! Error(message)
  }
}

/**
  * Companion object for [AkkaMesosScheduler].
  */
object AkkaMesosScheduler {

  /**
    * Common parent type of all [AkkaMesosScheduler] event messages.
    */
  sealed trait SchedulerMessage

  /**
    * Sent after successfully registering with a Mesos
    * master. A unique ID (generated by the master) used for
    * distinguishing this framework from others and MasterInfo
    * with the ip and port of the current master are provided.
    */
  case class Registered(
    frameworkId: FrameworkID,
    masterInfo: MasterInfo) extends SchedulerMessage

  /**
    * Sent after re-registering with a newly elected Mesos
    * master. This is only called when the scheduler has previously been
    * registered. MasterInfo containing the updated information about the
    * elected master is provided.
    */
  case class Reregistered(masterInfo: MasterInfo) extends SchedulerMessage

  /**
    * Sent when resources have been offered to this framework. A
    * single offer will only contain resources from a single slave.
    * Resources associated with an offer will not be re-offered to
    * _this_ framework until either (a) this framework has rejected
    * those resources or (b)
    * those resources have been rescinded.
    * Note that resources may be concurrently offered to more than one
    * framework at a time (depending on the allocator being used). In
    * that case, the first framework to launch tasks using those
    * resources will be able to use them while the other frameworks
    * will have those resources rescinded (or if a framework has
    * already launched tasks with those resources then those tasks will
    * fail with a TASK_LOST status and a message saying as much).
    */
  case class ResourceOffers(offers: Seq[Offer]) extends SchedulerMessage

  /**
    * Sent when an offer is no longer valid (e.g., the slave was
    * lost or another framework used resources in the offer). If for
    * whatever reason an offer is never rescinded (e.g., dropped
    * message, failing over framework, etc.), a framwork that attempts
    * to launch tasks using an invalid offer will receive TASK_LOST
    * status updats for those tasks.
    */
  case class OfferRescinded(offerId: OfferID) extends SchedulerMessage

  /**
    * Sent when the status of a task has changed (e.g., a slave is
    * lost and so the task is lost, a task finishes and an executor
    * sends a status update saying so, etc).
    */
  case class StatusUpdate(taskStatus: TaskStatus) extends SchedulerMessage

  /**
    * Sent when an executor sends a message. These messages are best
    * effort; do not expect a framework message to be retransmitted in
    * any reliable fashion.
    */
  case class FrameworkMessage(
    executorId: ExecutorID,
    slaveId: SlaveID,
    data: Seq[Byte]) extends SchedulerMessage

  /**
    * Sent when the scheduler becomes "disconnected" from the master
    * (e.g., the master fails and another is taking over).
    */
  case class Disconnected() extends SchedulerMessage

  /**
    * Sent when a slave has been determined unreachable (e.g.,
    * machine failure, network partition). Most frameworks will need to
    * reschedule any tasks launched on this slave on a new slave.
    */
  case class SlaveLost(slaveId: SlaveID) extends SchedulerMessage

  /**
    * Sent when an executor has exited/terminated. Note that any
    * tasks running will have TASK_LOST status updates automagically
    * generated.
    */
  case class ExecutorLost(
    executorId: ExecutorID,
    slaveId: SlaveID,
    status: Int) extends SchedulerMessage

  /**
    * Sent when there is an unrecoverable error in the scheduler or
    * scheduler driver. The driver will be aborted BEFORE this message
    * is received.
    */
  case class Error(message: String) extends SchedulerMessage

}